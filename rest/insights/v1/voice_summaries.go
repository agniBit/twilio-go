/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Insights
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"net/url"

	"github.com/twilio/twilio-go/client"
)

// Optional parameters for the method 'ListCallSummaries'
type ListCallSummariesParams struct {
	// A calling party. Could be an E.164 number, a SIP URI, or a Twilio Client registered name.
	From *string `json:"From,omitempty"`
	// A called party. Could be an E.164 number, a SIP URI, or a Twilio Client registered name.
	To *string `json:"To,omitempty"`
	// An origination carrier.
	FromCarrier *string `json:"FromCarrier,omitempty"`
	// A destination carrier.
	ToCarrier *string `json:"ToCarrier,omitempty"`
	// A source country code based on phone number in From.
	FromCountryCode *string `json:"FromCountryCode,omitempty"`
	// A destination country code. Based on phone number in To.
	ToCountryCode *string `json:"ToCountryCode,omitempty"`
	// A boolean flag indicating whether or not the calls were branded using Twilio Branded Calls.
	Branded *bool `json:"Branded,omitempty"`
	// A boolean flag indicating whether or not the caller was verified using SHAKEN/STIR.
	VerifiedCaller *bool `json:"VerifiedCaller,omitempty"`
	// A boolean flag indicating the presence of one or more [Voice Insights Call Tags](https://www.twilio.com/docs/voice/voice-insights/api/call/details-call-tags).
	HasTag *bool `json:"HasTag,omitempty"`
	// A Start time of the calls. xm (x minutes), xh (x hours), xd (x days), 1w, 30m, 3d, 4w or datetime-ISO. Defaults to 4h.
	StartTime *string `json:"StartTime,omitempty"`
	// An End Time of the calls. xm (x minutes), xh (x hours), xd (x days), 1w, 30m, 3d, 4w or datetime-ISO. Defaults to 0m.
	EndTime *string `json:"EndTime,omitempty"`
	// A Call Type of the calls. One of `carrier`, `sip`, `trunking` or `client`.
	CallType *string `json:"CallType,omitempty"`
	// A Call State of the calls. One of `ringing`, `completed`, `busy`, `fail`, `noanswer`, `canceled`, `answered`, `undialed`.
	CallState *string `json:"CallState,omitempty"`
	// A Direction of the calls. One of `outbound_api`, `outbound_dial`, `inbound`, `trunking_originating`, `trunking_terminating`.
	Direction *string `json:"Direction,omitempty"`
	// A Processing State of the Call Summaries. One of `completed`, `partial` or `all`.
	ProcessingState *string `json:"ProcessingState,omitempty"`
	// A Sort By criterion for the returned list of Call Summaries. One of `start_time` or `end_time`.
	SortBy *string `json:"SortBy,omitempty"`
	// A unique SID identifier of a Subaccount.
	Subaccount *string `json:"Subaccount,omitempty"`
	// A boolean flag indicating an abnormal session where the last SIP response was not 200 OK.
	AbnormalSession *bool `json:"AbnormalSession,omitempty"`
	// An Answered By value for the calls based on `Answering Machine Detection (AMD)`. One of `unknown`, `machine_start`, `machine_end_beep`, `machine_end_silence`, `machine_end_other`, `human` or `fax`.
	AnsweredBy *string `json:"AnsweredBy,omitempty"`
	// Either machine or human.
	AnsweredByAnnotation *string `json:"AnsweredByAnnotation,omitempty"`
	// A Connectivity Issue with the calls. One of `no_connectivity_issue`, `invalid_number`, `caller_id`, `dropped_call`, or `number_reachability`.
	ConnectivityIssueAnnotation *string `json:"ConnectivityIssueAnnotation,omitempty"`
	// A subjective Quality Issue with the calls. One of `no_quality_issue`, `low_volume`, `choppy_robotic`, `echo`, `dtmf`, `latency`, `owa`, `static_noise`.
	QualityIssueAnnotation *string `json:"QualityIssueAnnotation,omitempty"`
	// A boolean flag indicating spam calls.
	SpamAnnotation *bool `json:"SpamAnnotation,omitempty"`
	// A Call Score of the calls. Use a range of 1-5 to indicate the call experience score, with the following mapping as a reference for the rated call [5: Excellent, 4: Good, 3 : Fair, 2 : Poor, 1: Bad].
	CallScoreAnnotation *string `json:"CallScoreAnnotation,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
	// Max number of records to return.
	Limit *int `json:"limit,omitempty"`
}

func (params *ListCallSummariesParams) SetFrom(From string) *ListCallSummariesParams {
	params.From = &From
	return params
}
func (params *ListCallSummariesParams) SetTo(To string) *ListCallSummariesParams {
	params.To = &To
	return params
}
func (params *ListCallSummariesParams) SetFromCarrier(FromCarrier string) *ListCallSummariesParams {
	params.FromCarrier = &FromCarrier
	return params
}
func (params *ListCallSummariesParams) SetToCarrier(ToCarrier string) *ListCallSummariesParams {
	params.ToCarrier = &ToCarrier
	return params
}
func (params *ListCallSummariesParams) SetFromCountryCode(FromCountryCode string) *ListCallSummariesParams {
	params.FromCountryCode = &FromCountryCode
	return params
}
func (params *ListCallSummariesParams) SetToCountryCode(ToCountryCode string) *ListCallSummariesParams {
	params.ToCountryCode = &ToCountryCode
	return params
}
func (params *ListCallSummariesParams) SetBranded(Branded bool) *ListCallSummariesParams {
	params.Branded = &Branded
	return params
}
func (params *ListCallSummariesParams) SetVerifiedCaller(VerifiedCaller bool) *ListCallSummariesParams {
	params.VerifiedCaller = &VerifiedCaller
	return params
}
func (params *ListCallSummariesParams) SetHasTag(HasTag bool) *ListCallSummariesParams {
	params.HasTag = &HasTag
	return params
}
func (params *ListCallSummariesParams) SetStartTime(StartTime string) *ListCallSummariesParams {
	params.StartTime = &StartTime
	return params
}
func (params *ListCallSummariesParams) SetEndTime(EndTime string) *ListCallSummariesParams {
	params.EndTime = &EndTime
	return params
}
func (params *ListCallSummariesParams) SetCallType(CallType string) *ListCallSummariesParams {
	params.CallType = &CallType
	return params
}
func (params *ListCallSummariesParams) SetCallState(CallState string) *ListCallSummariesParams {
	params.CallState = &CallState
	return params
}
func (params *ListCallSummariesParams) SetDirection(Direction string) *ListCallSummariesParams {
	params.Direction = &Direction
	return params
}
func (params *ListCallSummariesParams) SetProcessingState(ProcessingState string) *ListCallSummariesParams {
	params.ProcessingState = &ProcessingState
	return params
}
func (params *ListCallSummariesParams) SetSortBy(SortBy string) *ListCallSummariesParams {
	params.SortBy = &SortBy
	return params
}
func (params *ListCallSummariesParams) SetSubaccount(Subaccount string) *ListCallSummariesParams {
	params.Subaccount = &Subaccount
	return params
}
func (params *ListCallSummariesParams) SetAbnormalSession(AbnormalSession bool) *ListCallSummariesParams {
	params.AbnormalSession = &AbnormalSession
	return params
}
func (params *ListCallSummariesParams) SetAnsweredBy(AnsweredBy string) *ListCallSummariesParams {
	params.AnsweredBy = &AnsweredBy
	return params
}
func (params *ListCallSummariesParams) SetAnsweredByAnnotation(AnsweredByAnnotation string) *ListCallSummariesParams {
	params.AnsweredByAnnotation = &AnsweredByAnnotation
	return params
}
func (params *ListCallSummariesParams) SetConnectivityIssueAnnotation(ConnectivityIssueAnnotation string) *ListCallSummariesParams {
	params.ConnectivityIssueAnnotation = &ConnectivityIssueAnnotation
	return params
}
func (params *ListCallSummariesParams) SetQualityIssueAnnotation(QualityIssueAnnotation string) *ListCallSummariesParams {
	params.QualityIssueAnnotation = &QualityIssueAnnotation
	return params
}
func (params *ListCallSummariesParams) SetSpamAnnotation(SpamAnnotation bool) *ListCallSummariesParams {
	params.SpamAnnotation = &SpamAnnotation
	return params
}
func (params *ListCallSummariesParams) SetCallScoreAnnotation(CallScoreAnnotation string) *ListCallSummariesParams {
	params.CallScoreAnnotation = &CallScoreAnnotation
	return params
}
func (params *ListCallSummariesParams) SetPageSize(PageSize int) *ListCallSummariesParams {
	params.PageSize = &PageSize
	return params
}
func (params *ListCallSummariesParams) SetLimit(Limit int) *ListCallSummariesParams {
	params.Limit = &Limit
	return params
}

// Retrieve a single page of CallSummaries records from the API. Request is executed immediately.
func (c *ApiService) PageCallSummaries(params *ListCallSummariesParams, pageToken, pageNumber string) (*ListCallSummariesResponse, error) {
	path := "/v1/Voice/Summaries"

	data := url.Values{}
	queryParams := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.From != nil {
		queryParams.Set("From", *params.From)
	}
	if params != nil && params.To != nil {
		queryParams.Set("To", *params.To)
	}
	if params != nil && params.FromCarrier != nil {
		queryParams.Set("FromCarrier", *params.FromCarrier)
	}
	if params != nil && params.ToCarrier != nil {
		queryParams.Set("ToCarrier", *params.ToCarrier)
	}
	if params != nil && params.FromCountryCode != nil {
		queryParams.Set("FromCountryCode", *params.FromCountryCode)
	}
	if params != nil && params.ToCountryCode != nil {
		queryParams.Set("ToCountryCode", *params.ToCountryCode)
	}
	if params != nil && params.Branded != nil {
		queryParams.Set("Branded", fmt.Sprint(*params.Branded))
	}
	if params != nil && params.VerifiedCaller != nil {
		queryParams.Set("VerifiedCaller", fmt.Sprint(*params.VerifiedCaller))
	}
	if params != nil && params.HasTag != nil {
		queryParams.Set("HasTag", fmt.Sprint(*params.HasTag))
	}
	if params != nil && params.StartTime != nil {
		queryParams.Set("StartTime", *params.StartTime)
	}
	if params != nil && params.EndTime != nil {
		queryParams.Set("EndTime", *params.EndTime)
	}
	if params != nil && params.CallType != nil {
		queryParams.Set("CallType", *params.CallType)
	}
	if params != nil && params.CallState != nil {
		queryParams.Set("CallState", *params.CallState)
	}
	if params != nil && params.Direction != nil {
		queryParams.Set("Direction", *params.Direction)
	}
	if params != nil && params.ProcessingState != nil {
		queryParams.Set("ProcessingState", *params.ProcessingState)
	}
	if params != nil && params.SortBy != nil {
		queryParams.Set("SortBy", *params.SortBy)
	}
	if params != nil && params.Subaccount != nil {
		queryParams.Set("Subaccount", *params.Subaccount)
	}
	if params != nil && params.AbnormalSession != nil {
		queryParams.Set("AbnormalSession", fmt.Sprint(*params.AbnormalSession))
	}
	if params != nil && params.AnsweredBy != nil {
		queryParams.Set("AnsweredBy", *params.AnsweredBy)
	}
	if params != nil && params.AnsweredByAnnotation != nil {
		queryParams.Set("AnsweredByAnnotation", *params.AnsweredByAnnotation)
	}
	if params != nil && params.ConnectivityIssueAnnotation != nil {
		queryParams.Set("ConnectivityIssueAnnotation", *params.ConnectivityIssueAnnotation)
	}
	if params != nil && params.QualityIssueAnnotation != nil {
		queryParams.Set("QualityIssueAnnotation", *params.QualityIssueAnnotation)
	}
	if params != nil && params.SpamAnnotation != nil {
		queryParams.Set("SpamAnnotation", fmt.Sprint(*params.SpamAnnotation))
	}
	if params != nil && params.CallScoreAnnotation != nil {
		queryParams.Set("CallScoreAnnotation", *params.CallScoreAnnotation)
	}
	if params != nil && params.PageSize != nil {
		queryParams.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	if pageToken != "" {
		data.Set("PageToken", pageToken)
	}
	if pageNumber != "" {
		data.Set("Page", pageNumber)
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers, queryParams)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListCallSummariesResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Lists CallSummaries records from the API as a list. Unlike stream, this operation is eager and loads 'limit' records into memory before returning.
func (c *ApiService) ListCallSummaries(params *ListCallSummariesParams) ([]InsightsV1CallSummaries, error) {
	response, errors := c.StreamCallSummaries(params)

	records := make([]InsightsV1CallSummaries, 0)
	for record := range response {
		records = append(records, record)
	}

	if err := <-errors; err != nil {
		return nil, err
	}

	return records, nil
}

// Streams CallSummaries records from the API as a channel stream. This operation lazily loads records as efficiently as possible until the limit is reached.
func (c *ApiService) StreamCallSummaries(params *ListCallSummariesParams) (chan InsightsV1CallSummaries, chan error) {
	if params == nil {
		params = &ListCallSummariesParams{}
	}
	params.SetPageSize(client.ReadLimits(params.PageSize, params.Limit))

	recordChannel := make(chan InsightsV1CallSummaries, 1)
	errorChannel := make(chan error, 1)

	response, err := c.PageCallSummaries(params, "", "")
	if err != nil {
		errorChannel <- err
		close(recordChannel)
		close(errorChannel)
	} else {
		go c.streamCallSummaries(response, params, recordChannel, errorChannel)
	}

	return recordChannel, errorChannel
}

func (c *ApiService) streamCallSummaries(response *ListCallSummariesResponse, params *ListCallSummariesParams, recordChannel chan InsightsV1CallSummaries, errorChannel chan error) {
	curRecord := 1

	for response != nil {
		responseRecords := response.CallSummaries
		for item := range responseRecords {
			recordChannel <- responseRecords[item]
			curRecord += 1
			if params.Limit != nil && *params.Limit < curRecord {
				close(recordChannel)
				close(errorChannel)
				return
			}
		}

		record, err := client.GetNext(c.baseURL, response, c.getNextListCallSummariesResponse)
		if err != nil {
			errorChannel <- err
			break
		} else if record == nil {
			break
		}

		response = record.(*ListCallSummariesResponse)
	}

	close(recordChannel)
	close(errorChannel)
}

func (c *ApiService) getNextListCallSummariesResponse(nextPageUrl string) (interface{}, error) {
	if nextPageUrl == "" {
		return nil, nil
	}
	resp, err := c.requestHandler.Get(nextPageUrl, nil, nil, nil)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListCallSummariesResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}
	return ps, nil
}
